generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- ENUMS (Padronização) ---
enum ValidationStatus {
  PENDING
  APPROVED
  REJECTED
}

enum QuestionType {
  TEXT
  DATE
  SELECT
  FILE
}

// --- FLUXO DE ONBOARDING ---

model OnboardingProcess {
  id          String   @id @default(uuid())
  title       String
  description String
  createdAt   DateTime @default(now())
  
  phases      Phase[]
}

model Phase {
  id        String   @id @default(uuid())
  title     String
  order     Int
  
  processId String
  process   OnboardingProcess @relation(fields: [processId], references: [id], onDelete: Cascade)
  
  questions Question[]
  employees Employee[] // Funcionários que estão atualmente nesta fase
}

model Question {
  id       String       @id @default(uuid())
  label    String
  type     QuestionType // Usando Enum para segurança de tipos
  required Boolean      @default(false)
  order    Int
  
  phaseId  String
  phase    Phase        @relation(fields: [phaseId], references: [id], onDelete: Cascade)
  
  options  Option[]
  answers  Answer[]
}

model Option {
  id         String   @id @default(uuid())
  label      String
  value      String
  order      Int
  
  questionId String
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
}

// --- FUNCIONÁRIO E DADOS PESSOAIS ---

model Employee {
  id        String   @id @default(uuid())
  name      String
  email     String   @unique
  cpf       String   @unique
  createdAt DateTime @default(now())

  // Controle de progresso
  currentPhaseId String
  currentPhase   Phase  @relation(fields: [currentPhaseId], references: [id])

  feedback       String? // Feedback do RH para o candidato
  corrections    String[] // IDs dos campos/perguntas que precisam de correção
  status         ValidationStatus @default(PENDING)

  // Relacionamentos
  address   Address?
  documents Document[]
  answers   Answer[]
}

model Address {
  id           String  @id @default(uuid())
  cep          String
  street       String
  number       String
  complement   String?
  neighborhood String
  city         String
  state        String

  employeeId   String   @unique
  employee     Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)
}

// --- RESPOSTAS E DOCUMENTOS ---

model Document {
  id         String   @id @default(uuid())
  fileName   String
  mimeType   String
  fileData   Bytes    // Armazenamento binário
  uploadedAt DateTime @default(now())

  employeeId String
  employee   Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  // Relacionamento com a resposta (Se esse documento for uma resposta de upload)
  answerId   String?  @unique
  answer     Answer?  @relation(fields: [answerId], references: [id])
}

model Answer {
  id    String  @id @default(uuid())
  value String? // Texto, Data ou nulo (se for arquivo)

  // Se a resposta for um arquivo, o link está aqui (relação 1:1)
  document Document?

  employeeId String
  employee   Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  questionId String
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  // Histórico de validação do RH (BCNF)
  validations Validation[]

  // Garante que um funcionário só responde uma vez cada pergunta
  @@unique([employeeId, questionId])
}

// --- RH E VALIDAÇÃO (Nova Tabela) ---

model Validation {
  id         String           @id @default(uuid())
  status     ValidationStatus @default(PENDING)
  comment    String?          // Motivo da rejeição ou obs
  reviewedAt DateTime         @default(now())

  // ID do usuário do RH que validou (pode conectar a uma tabela User futura)
  reviewerId String

  answerId   String
  answer     Answer @relation(fields: [answerId], references: [id], onDelete: Cascade)

  @@index([answerId])
  @@index([status])
}